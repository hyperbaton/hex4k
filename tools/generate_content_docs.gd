@tool
extends EditorScript

## Generates Mermaid diagrams documenting tech progression and content unlocks.
## Run from the Godot editor: File > Run (or Ctrl+Shift+X) with this script open.
## Output: docs/content_progression.md


func _run() -> void:
	var branches: Dictionary = _load_json("res://data/tech/branches.json")
	var milestones: Dictionary = _load_all_json("res://data/tech/milestones")
	var buildings: Dictionary = _load_all_json("res://data/buildings")
	var units: Dictionary = _load_all_json("res://data/units")

	var resources: Dictionary = _load_all_json("res://data/resources")

	var output: String = ""
	output += "# Content Progression\n\n"
	output += "_Auto-generated by `tools/generate_content_docs.gd` â€” do not edit manually._\n\n"
	output += "## Tech Tree\n\n"
	output += "Shows all branches and milestones. Milestones are ordered by required branch level.\n"
	output += "Dashed arrows show cross-branch dependencies. "
	output += "Dotted arrows show which milestone unlocks a new branch.\n\n"
	output += _generate_tech_tree(branches, milestones)
	output += "\n\n## Content Unlocks\n\n"
	output += "Shows what each milestone unlocks: buildings, units, and resources.\n"
	output += "Milestone sequences are preserved within branch subgraphs.\n"
	output += "Buildings and units sit outside branches. Resources show production and consumption flows.\n\n"
	output += _generate_unlock_map(branches, milestones, buildings, units, resources)
	output += "\n\n## Branch Unlock Chain\n\n"
	output += "Shows how branches are unlocked from other branches via milestones.\n\n"
	output += _generate_branch_chain(branches)

	var path: String = "res://docs/content_progression.md"
	var file: FileAccess = FileAccess.open(path, FileAccess.WRITE)
	if file:
		file.store_string(output)
		file.close()
		print("Content progression docs written to: ", path)
	else:
		push_error("Failed to write to: " + path)


# -- Tech Tree Diagram --

func _generate_tech_tree(branches: Dictionary, milestones: Dictionary) -> String:
	var lines: PackedStringArray = PackedStringArray()
	lines.append("```mermaid")
	lines.append("graph TD")

	# Group milestones by branch, sorted by level
	var by_branch: Dictionary = {}
	for ms_id: String in milestones:
		var ms: Dictionary = milestones[ms_id]
		var branch: String = ms.get("branch", "")
		if branch == "":
			continue
		if not by_branch.has(branch):
			by_branch[branch] = []
		by_branch[branch].append({"id": ms_id, "data": ms})

	for branch_id: String in by_branch:
		by_branch[branch_id].sort_custom(func(a: Dictionary, b: Dictionary) -> bool:
			return _get_own_level(a["data"]) < _get_own_level(b["data"])
		)

	# Define branch order: foundational first, then derived
	var branch_order: Array[String] = _get_branch_order(branches)

	# Subgraphs per branch
	for branch_id: String in branch_order:
		if not by_branch.has(branch_id):
			continue
		var branch_data: Dictionary = branches.get(branch_id, {})
		var branch_name: String = branch_data.get("name", branch_id)
		var color: String = branch_data.get("color", "#666666")

		lines.append("")
		lines.append("  subgraph %s_sub[\"%s\"]" % [branch_id, branch_name])
		lines.append("    direction LR")

		var ms_list: Array = by_branch[branch_id]
		# Nodes
		for entry: Dictionary in ms_list:
			var ms_id: String = entry["id"]
			var ms: Dictionary = entry["data"]
			var label: String = ms.get("name", ms_id)
			var level: float = _get_own_level(ms)
			lines.append("    %s[\"%s<br/><small>lvl %.0f</small>\"]" % [ms_id, label, level])

		# Sequential arrows within branch
		for i: int in range(ms_list.size() - 1):
			var from_id: String = ms_list[i]["id"]
			var to_id: String = ms_list[i + 1]["id"]
			lines.append("    %s --> %s" % [from_id, to_id])

		lines.append("  end")

		# Style the subgraph
		lines.append("  style %s_sub fill:%s18,stroke:%s,stroke-width:2px,color:#fff" % [branch_id, color, color])

	# Cross-branch dependencies (dashed arrows)
	lines.append("")
	lines.append("  %% Cross-branch dependencies")
	for ms_id: String in milestones:
		var ms: Dictionary = milestones[ms_id]
		var own_branch: String = ms.get("branch", "")
		var requirements: Array = ms.get("requirements", [])
		for req: Dictionary in requirements:
			var req_branch: String = req.get("branch", "")
			var req_level: float = req.get("level", 0.0)
			if req_branch != own_branch and req_branch != "":
				if not by_branch.has(req_branch):
					push_warning("Milestone '%s' requires branch '%s' which has no milestones" % [ms_id, req_branch])
					continue
				var source_ms: String = _find_milestone_at_level(by_branch, req_branch, req_level)
				if source_ms != "":
					lines.append("  %s -. \"requires %s lvl %.0f\" .-> %s" % [source_ms, req_branch.replace("_", " "), req_level, ms_id])

	# Branch unlock arrows (dotted)
	lines.append("")
	lines.append("  %% Branch unlocks")
	for branch_id: String in branches:
		var branch_data: Dictionary = branches[branch_id]
		var starts_from: Variant = branch_data.get("starts_from")
		if starts_from is Dictionary:
			var source_milestone: String = starts_from.get("milestone", "")
			if source_milestone == "" or not by_branch.has(branch_id):
				continue
			# Only emit arrow if the source milestone actually exists as a node
			if not milestones.has(source_milestone):
				push_warning("Branch '%s' references missing milestone '%s' in starts_from" % [branch_id, source_milestone])
				continue
			var first_ms: String = by_branch[branch_id][0]["id"]
			lines.append("  %s -. \"unlocks branch\" .-> %s" % [source_milestone, first_ms])

	lines.append("```")
	return "\n".join(lines)


# -- Content Unlock Map --

func _generate_unlock_map(branches: Dictionary, milestones: Dictionary, buildings: Dictionary, units: Dictionary, resources: Dictionary) -> String:
	# -- Build indexes --

	# milestone -> {buildings: [], units: [], resources: []}
	var ms_unlocks: Dictionary = {}

	for b_id: String in buildings:
		var b: Dictionary = buildings[b_id]
		var reqs: Array = _get_milestones_required(b)
		for ms_id: String in reqs:
			if not ms_unlocks.has(ms_id):
				ms_unlocks[ms_id] = {"buildings": [], "units": [], "resources": []}
			ms_unlocks[ms_id]["buildings"].append(b_id)

	for u_id: String in units:
		var u: Dictionary = units[u_id]
		var reqs: Array = u.get("milestones_required", [])
		for ms_id: String in reqs:
			if not ms_unlocks.has(ms_id):
				ms_unlocks[ms_id] = {"buildings": [], "units": [], "resources": []}
			ms_unlocks[ms_id]["units"].append(u_id)

	for r_id: String in resources:
		var r: Dictionary = resources[r_id]
		var reqs: Array = _get_milestones_required(r)
		for ms_id: String in reqs:
			if not ms_unlocks.has(ms_id):
				ms_unlocks[ms_id] = {"buildings": [], "units": [], "resources": []}
			ms_unlocks[ms_id]["resources"].append(r_id)

	# Resources to exclude from flow arrows (mechanical resources that every building uses)
	var flow_excluded: Array[String] = ["research", "population", "admin_capacity"]

	# building -> {produces: [resource_id], consumes: [resource_id]}
	var building_flows: Dictionary = {}
	for b_id: String in buildings:
		var b: Dictionary = buildings[b_id]
		var produces: Array[String] = []
		var consumes: Array[String] = []
		var production: Variant = b.get("production", {})
		if production is Dictionary:
			for entry: Dictionary in production.get("produces", []):
				var res: String = entry.get("resource", "")
				if res != "" and res not in flow_excluded:
					if res not in produces:
						produces.append(res)
			for entry: Dictionary in production.get("consumes", []):
				var res: String = entry.get("resource", "")
				if res != "" and res not in flow_excluded:
					if res not in consumes:
						consumes.append(res)
		building_flows[b_id] = {"produces": produces, "consumes": consumes}

	# Collect which resources are actually referenced (produced or consumed)
	var referenced_resources: Dictionary = {}
	for b_id: String in building_flows:
		for res: String in building_flows[b_id]["produces"]:
			referenced_resources[res] = true
		for res: String in building_flows[b_id]["consumes"]:
			referenced_resources[res] = true

	# Resources available from start (no milestone requirement)
	var starting_resources: Array[String] = []
	for r_id: String in resources:
		var r: Dictionary = resources[r_id]
		var reqs: Array = _get_milestones_required(r)
		if reqs.is_empty() and referenced_resources.has(r_id):
			starting_resources.append(r_id)

	# building -> upgrades_to
	var upgrade_pairs: Array[Dictionary] = []
	for b_id: String in buildings:
		var b: Dictionary = buildings[b_id]
		var upgrades_to: Variant = b.get("upgrades_to")
		if upgrades_to is String and upgrades_to != "":
			upgrade_pairs.append({"from": b_id, "to": upgrades_to})

	# Group milestones by branch, sorted by level
	var by_branch: Dictionary = {}
	for ms_id: String in milestones:
		var ms: Dictionary = milestones[ms_id]
		var branch: String = ms.get("branch", "")
		if branch == "":
			continue
		if not by_branch.has(branch):
			by_branch[branch] = []
		by_branch[branch].append({"id": ms_id, "data": ms})

	for branch_id: String in by_branch:
		by_branch[branch_id].sort_custom(func(a: Dictionary, b: Dictionary) -> bool:
			return _get_own_level(a["data"]) < _get_own_level(b["data"])
		)

	# -- Build diagram --

	var lines: PackedStringArray = PackedStringArray()
	lines.append("```mermaid")
	lines.append("graph LR")
	var branch_order: Array[String] = _get_branch_order(branches)

	# Milestone subgraphs (with sequences, no content inside)
	for branch_id: String in branch_order:
		if not by_branch.has(branch_id):
			continue
		var branch_data: Dictionary = branches.get(branch_id, {})
		var branch_name: String = branch_data.get("name", branch_id)
		var color: String = branch_data.get("color", "#666666")

		# Only include branches that unlock something
		var branch_has_unlocks: bool = false
		for entry: Dictionary in by_branch[branch_id]:
			if ms_unlocks.has(entry["id"]):
				branch_has_unlocks = true
				break
		if not branch_has_unlocks:
			continue

		lines.append("")
		lines.append("  subgraph %s_sub[\"%s\"]" % [branch_id, branch_name])
		lines.append("    direction LR")

		var ms_list: Array = by_branch[branch_id]
		# Only emit milestones that unlock content
		var active_ids: Array[String] = []
		for entry: Dictionary in ms_list:
			if ms_unlocks.has(entry["id"]):
				active_ids.append(entry["id"])
				var ms: Dictionary = entry["data"]
				var label: String = ms.get("name", entry["id"])
				lines.append("    %s_u([\"%s\"])" % [entry["id"], label])

		# Sequential arrows between active milestones
		for i: int in range(active_ids.size() - 1):
			lines.append("    %s_u --> %s_u" % [active_ids[i], active_ids[i + 1]])

		lines.append("  end")
		lines.append("  style %s_sub fill:%s18,stroke:%s,stroke-width:2px,color:#fff" % [branch_id, color, color])

	# Building and unit nodes (outside subgraphs)
	lines.append("")
	lines.append("  %% Buildings and units")
	var emitted_buildings: Dictionary = {}
	var emitted_units: Dictionary = {}

	for ms_id: String in ms_unlocks:
		for b_id: String in ms_unlocks[ms_id]["buildings"]:
			if not emitted_buildings.has(b_id):
				var b_name: String = _format_name(b_id, buildings[b_id])
				lines.append("  b_%s([\"%s\"]):::building" % [b_id, b_name])
				emitted_buildings[b_id] = true
		for u_id: String in ms_unlocks[ms_id]["units"]:
			if not emitted_units.has(u_id):
				var u_name: String = _format_name(u_id, units[u_id])
				lines.append("  u_%s{{\"%s\"}}:::unit" % [u_id, u_name])
				emitted_units[u_id] = true

	# Also emit buildings with no milestone requirement but that participate in flows
	for b_id: String in buildings:
		var reqs: Array = _get_milestones_required(buildings[b_id])
		if reqs.is_empty() and not emitted_buildings.has(b_id):
			var flows: Dictionary = building_flows[b_id]
			if flows["produces"].size() > 0 or flows["consumes"].size() > 0:
				var b_name: String = _format_name(b_id, buildings[b_id])
				lines.append("  b_%s([\"%s\"]):::building" % [b_id, b_name])
				emitted_buildings[b_id] = true

	# Milestone -> building/unit unlock arrows
	lines.append("")
	lines.append("  %% Milestone unlock arrows")
	for ms_id: String in ms_unlocks:
		for b_id: String in ms_unlocks[ms_id]["buildings"]:
			lines.append("  %s_u --> b_%s" % [ms_id, b_id])
		for u_id: String in ms_unlocks[ms_id]["units"]:
			lines.append("  %s_u --> u_%s" % [ms_id, u_id])

	# Resource nodes
	lines.append("")
	lines.append("  %% Resources")
	var emitted_resources: Dictionary = {}
	# Resources unlocked by milestones
	for ms_id: String in ms_unlocks:
		for r_id: String in ms_unlocks[ms_id]["resources"]:
			if not emitted_resources.has(r_id):
				var r_name: String = _format_name(r_id, resources[r_id])
				lines.append("  r_%s[/\"%s\"/]:::resource" % [r_id, r_name])
				emitted_resources[r_id] = true
	# Starting resources
	for r_id: String in starting_resources:
		if not emitted_resources.has(r_id):
			var r_name: String = _format_name(r_id, resources[r_id])
			lines.append("  r_%s[/\"%s\"/]:::resource_start" % [r_id, r_name])
			emitted_resources[r_id] = true
	# Resources only referenced via production/consumption but not yet emitted
	for r_id: String in referenced_resources:
		if not emitted_resources.has(r_id) and resources.has(r_id):
			var r_name: String = _format_name(r_id, resources[r_id])
			lines.append("  r_%s[/\"%s\"/]:::resource" % [r_id, r_name])
			emitted_resources[r_id] = true

	# Milestone -> resource unlock arrows
	lines.append("")
	lines.append("  %% Milestone unlocks resources")
	for ms_id: String in ms_unlocks:
		for r_id: String in ms_unlocks[ms_id]["resources"]:
			lines.append("  %s_u -.-> r_%s" % [ms_id, r_id])

	# Building production arrows (building --> resource)
	lines.append("")
	lines.append("  %% Production: building produces resource")
	for b_id: String in building_flows:
		if not emitted_buildings.has(b_id):
			continue
		for res: String in building_flows[b_id]["produces"]:
			if emitted_resources.has(res):
				lines.append("  b_%s -- produces --> r_%s" % [b_id, res])

	# Building consumption arrows (resource --> building)
	lines.append("")
	lines.append("  %% Consumption: building consumes resource")
	for b_id: String in building_flows:
		if not emitted_buildings.has(b_id):
			continue
		for res: String in building_flows[b_id]["consumes"]:
			if emitted_resources.has(res):
				lines.append("  r_%s -. consumes .-> b_%s" % [res, b_id])

	# Building upgrade arrows
	if upgrade_pairs.size() > 0:
		lines.append("")
		lines.append("  %% Building upgrades")
		for pair: Dictionary in upgrade_pairs:
			if emitted_buildings.has(pair["from"]) and emitted_buildings.has(pair["to"]):
				lines.append("  b_%s == upgrades ==> b_%s" % [pair["from"], pair["to"]])

	# Class definitions
	lines.append("")
	lines.append("  %% Styling")
	lines.append("  classDef building fill:#2d5a1e,stroke:#4a7c3f,color:#fff")
	lines.append("  classDef unit fill:#1e3a5a,stroke:#4682B4,color:#fff")
	lines.append("  classDef resource fill:#8B6914,stroke:#DAA520,color:#fff")
	lines.append("  classDef resource_start fill:#8B6914,stroke:#FFD700,stroke-width:3px,color:#fff")

	lines.append("```")
	return "\n".join(lines)


# -- Branch Chain Diagram --

func _generate_branch_chain(branches: Dictionary) -> String:
	var lines: PackedStringArray = PackedStringArray()
	lines.append("```mermaid")
	lines.append("graph LR")
	lines.append("")

	# Foundational branches
	for branch_id: String in branches:
		var b: Dictionary = branches[branch_id]
		var name: String = b.get("name", branch_id)
		var color: String = b.get("color", "#666666")
		var starts_from: Variant = b.get("starts_from")
		if starts_from == null:
			lines.append("  %s[\"%s\"]" % [branch_id, name])
			lines.append("  style %s fill:%s,stroke:%s,color:#fff" % [branch_id, color, color])

	lines.append("")

	# Derived branches with unlock edges
	for branch_id: String in branches:
		var b: Dictionary = branches[branch_id]
		var name: String = b.get("name", branch_id)
		var color: String = b.get("color", "#666666")
		var starts_from: Variant = b.get("starts_from")
		if starts_from is Dictionary:
			var source_branch: String = starts_from.get("branch", "")
			var source_milestone: String = starts_from.get("milestone", "")
			lines.append("  %s[\"%s\"]" % [branch_id, name])
			lines.append("  style %s fill:%s,stroke:%s,color:#fff" % [branch_id, color, color])
			var milestone_label: String = source_milestone.replace("_", " ").capitalize()
			lines.append("  %s -- \"%s\" --> %s" % [source_branch, milestone_label, branch_id])

	lines.append("```")
	return "\n".join(lines)


# -- Helpers --

func _load_json(path: String) -> Dictionary:
	var file: FileAccess = FileAccess.open(path, FileAccess.READ)
	if not file:
		push_error("Cannot open: " + path)
		return {}
	var text: String = file.get_as_text()
	file.close()
	var json: JSON = JSON.new()
	var err: int = json.parse(text)
	if err != OK:
		push_error("JSON parse error in %s: %s" % [path, json.get_error_message()])
		return {}
	return json.data


func _load_all_json(dir_path: String) -> Dictionary:
	var result: Dictionary = {}
	var dir: DirAccess = DirAccess.open(dir_path)
	if not dir:
		push_error("Cannot open directory: " + dir_path)
		return result
	dir.list_dir_begin()
	var file_name: String = dir.get_next()
	while file_name != "":
		if file_name.ends_with(".json"):
			var id: String = file_name.trim_suffix(".json")
			result[id] = _load_json(dir_path + "/" + file_name)
		file_name = dir.get_next()
	dir.list_dir_end()
	return result


func _get_own_level(ms: Dictionary) -> float:
	"""Get the level required in the milestone's own branch."""
	var branch: String = ms.get("branch", "")
	var requirements: Array = ms.get("requirements", [])
	for req: Dictionary in requirements:
		if req.get("branch", "") == branch:
			return req.get("level", 0.0)
	return 0.0


func _find_milestone_at_level(by_branch: Dictionary, branch_id: String, level: float) -> String:
	"""Find the highest milestone in a branch that is at or below the given level."""
	if not by_branch.has(branch_id):
		return ""
	var ms_list: Array = by_branch[branch_id]
	var best: String = ""
	var best_level: float = -1.0
	for entry: Dictionary in ms_list:
		var ms_level: float = _get_own_level(entry["data"])
		if ms_level <= level and ms_level > best_level:
			best = entry["id"]
			best_level = ms_level
	# If no milestone at or below, use the last one in the branch
	if best == "" and ms_list.size() > 0:
		best = ms_list[ms_list.size() - 1]["id"]
	return best


func _get_milestones_required(data: Dictionary) -> Array:
	"""Extract milestones_required from building data, checking both top-level and nested."""
	var reqs: Variant = data.get("milestones_required")
	if reqs is Array:
		return reqs
	var requirements: Variant = data.get("requirements")
	if requirements is Dictionary:
		reqs = requirements.get("milestones_required")
		if reqs is Array:
			return reqs
	return []


func _format_name(id: String, data: Dictionary) -> String:
	"""Get display name from data, falling back to formatted id."""
	var name: Variant = data.get("name")
	if name is String and name != "":
		return name
	return id.replace("_", " ").capitalize()


func _get_branch_order(branches: Dictionary) -> Array[String]:
	"""Return branches ordered: foundational first, then derived sorted by depth."""
	var foundational: Array[String] = []
	var derived: Array[String] = []
	for branch_id: String in branches:
		var b: Dictionary = branches[branch_id]
		if b.get("starts_from") == null:
			foundational.append(branch_id)
		else:
			derived.append(branch_id)

	# Sort derived by their source branch depth (simple: foundational sources first)
	derived.sort_custom(func(a: String, b: String) -> bool:
		var a_source: String = ""
		var b_source: String = ""
		var a_data: Variant = branches[a].get("starts_from")
		var b_data: Variant = branches[b].get("starts_from")
		if a_data is Dictionary:
			a_source = a_data.get("branch", "")
		if b_data is Dictionary:
			b_source = b_data.get("branch", "")
		var a_foundational: bool = a_source in foundational
		var b_foundational: bool = b_source in foundational
		if a_foundational != b_foundational:
			return a_foundational
		return a < b
	)

	var result: Array[String] = []
	result.append_array(foundational)
	result.append_array(derived)
	return result
